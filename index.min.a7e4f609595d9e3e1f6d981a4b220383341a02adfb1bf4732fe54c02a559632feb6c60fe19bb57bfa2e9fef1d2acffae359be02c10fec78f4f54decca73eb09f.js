var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(n){const s=suggestions.classList.contains("d-none");if(s)return;const e=[...suggestions.querySelectorAll("a")];if(e.length===0)return;const t=e.indexOf(document.activeElement);if(n.key==="ArrowUp"){n.preventDefault();const s=t>0?t-1:0;e[s].focus()}else if(n.key==="ArrowDown"){n.preventDefault();const s=t+1<e.length?t+1:t;e[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/get-started/introduction/",title:"Introduction",description:"Summary of what rulex is and what it looks like",content:"Rulex is a language that compiles to regular expressions. It is currently in an alpha stage and will likely change in the next few releases.\nUsage #\rRulex can be used with a CLI or a Rust macro. See installation instructions.\nYou should also enable Unicode support in your regex engine if it isn\u0026rsquo;t supported by default. See instructions.\nSummary #\rðŸ‘‰ \rHere you can see all the features at a glance. Don't worry, they will be explained in detail in the language tour. \r\rOn the left are rulex expressions, on the right are the equivalent regexes:\n# String 'hello world' # hello world # Greedy repetition 'hello'{1,5} # (?:hello){1,5} 'hello'* # (?:hello)* 'hello'+ # (?:hello)+ # Lazy repetition 'hello'{1,5} lazy # (?:hello){1,5}? 'hello'* lazy # (?:hello)*? 'hello'+ lazy # (?:hello)+? # Alternation 'hello' | 'world' # hello|world # Character classes ['aeiou'] # [aeiou] ['p'-'s'] # [p-s] # Named character classes [.] [w] [s] [n] # .\\w\\s\\n # Combined [w 'a' 't'-'z' U+15] # [\\wat-z\\x15] # Negated character classes !['a' 't'-'z'] # [^at-z] # Unicode [Greek] U+30F Grapheme # \\p{Greek}\\u030F\\X # Boundaries \u0026lt;% %\u0026gt; # ^$ % 'hello' !% # \\bhello\\B # Non-capturing groups 'terri' ('fic' | 'ble') # terri(?:fic|ble) # Capturing groups :('test') # (test) :name('test') # (?P\u0026lt;name\u0026gt;test) # Lookahead/lookbehind \u0026gt;\u0026gt; 'foo' | 'bar' # (?=foo|bar) \u0026lt;\u0026lt; 'foo' | 'bar' # (?\u0026lt;=foo|bar) !\u0026gt;\u0026gt; 'foo' | 'bar' # (?!foo|bar) !\u0026lt;\u0026lt; 'foo' | 'bar' # (?\u0026lt;!foo|bar) # Backreferences :('test') ::1 # (test)\\1 :name('test') ::name # (?P\u0026lt;name\u0026gt;test)\\1 # Ranges range '0'-'999' # 0|[1-9][0-9]{0,2} range '0'-'255' # 0|1[0-9]{0,2}|2(?:[0-4][0-9]?|5[0-5]?|[6-9])?|[3-9][0-9]?  Variables #\rlet operator = '+' | '-' | '*' | '/'; let number = '-'? [digit]+; number (operator number)*  "}),e.add({id:1,href:"/docs/get-started/quick-start/",title:"Quick Start",description:"Summary of how to start using rulex.",content:"CLI #\rThe CLI allows you to compile rulex expressions to regexes in the command line.\nUse pre-built binaries #\rBinaries are available for Windows, Linux and macOS. Download them from the releases page.\nInstall from source #\rThis requires that a recent Rust toolchain is installed. Instructions for how to install Rust can be found here.\nInstall the CLI with\ncargo install rulex-bin  Get help #\rTo find out how to use the CLI, run\nrulex --help  Rust macro #\rIf you want to write a rulex directly in your Rust source code, the rulex-macro got you covered. Add this to your Cargo.toml:\nrulex-macro = \u0026quot;0.4.1\u0026quot;  Then you can import and use it with\nuse rulex_macro::rulex; const MY_REGEX: \u0026amp;str = rulex!([\u0026quot;great!\u0026quot;] | \u0026quot;great!\u0026quot;);  Documentation can be found here.\n"}),e.add({id:2,href:"/docs/get-started/enable-unicode/",title:"Enable Unicode Support",description:"Configure the RegExp engine to support Unicode.",content:"Rulex has good Unicode support, but you might still have to enable Unicode support in your regex engine. This document explains how to do that for various regex engines.\nIf some information here is missing, outdated or needs clarification, I would greatly appreciate your help! You can edit this file on GitHub.\nRust #\rThe Rust regex crate is Unicode-aware by default. There\u0026rsquo;s nothing you need to do.\nJavaScript #\rIn JavaScript, set the u flag, for example /[\\w\\s]/u. This makes it possible to use Unicode properties (\\p{...}) and code points outside of the BMP (\\u{...}).\nSince \\w and \\d are not Unicode aware even when the u flag is enabled, rulex polyfills them. However, word boundaries aren\u0026rsquo;t Unicode aware, and there\u0026rsquo;s no straightforward solution for this. To make word boundaries behave correctly, you need to substitute % and !% with\n(\u0026lt;\u0026lt; [w]) (!\u0026gt;\u0026gt; [w]) | (!\u0026lt;\u0026lt; [w]) (\u0026gt;\u0026gt; [w]) # and (\u0026lt;\u0026lt; [w]) (\u0026gt;\u0026gt; [w]) | (!\u0026lt;\u0026lt; [w]) (!\u0026gt;\u0026gt; [w])  respectively.\nPHP #\rPHP is Unicode-aware if the u flag is set, and this also applies to \\w, \\d, \\s and \\b. For example, '/\\w+/u' matches a word in any script.\nPCRE #\rPCRE supports Unicode, but to make \\w, \\d, \\s and \\b Unicode-aware, you need to enable both PCRE_UTF8 and PCRE_UCP.\nJava #\rIn Java, add (?U) in front of the regex to make it Unicode-aware. For example, \u0026quot;(?U)\\\\w+\u0026quot; matches a word in any script.\nRuby #\rIn Ruby, add (?u) in front of the regex to make it Unicode-aware. For example, /(?u)\\w+/ matches a word in any script.\nPython #\rIn the Python re module, \\w, \\d, \\s and \\b are Unicode-aware since Python 3.\nIf you\u0026rsquo;re still using Python 2, you can use the regex module from November 2021; releases newer than that don\u0026rsquo;t support Python 2.\n"}),e.add({id:3,href:"/docs/language-tour/basics/",title:"Basics",description:"Comments, strings, alternation",content:"First, let\u0026rsquo;s get familiar with the basic building blocks of the language.\nRulex expressions (rulexes for short) describe the syntactical structure of a text. There are several kinds of expressions, which will be explained now.\nIn Rulex, whitespace is insignificant, except between quotes. This means that we can add spaces and line breaks to make the code look clearer. We can also add comments to explain what the expressions are doing. They start with a # and span until the end of the line:\n# this is a comment # comments are ignored by rulex!  Strings #\rIn Rulex, characters that should be matched as-is, are always wrapped in quotes. We can use double quotes (\"\") or single quotes (''). Text wrapped in quotes we call a string. It matches the exact content of the string:\n\u0026quot;test\u0026quot;  In double quoted strings (\"...\"), double quotes can be escaped by prepending a backslash. Backslashes also must be escaped:\n\u0026quot;\\\u0026quot;C:\\\\windows\\\u0026quot;\u0026quot; # is equivalent to '\u0026quot;C:\\windows\u0026quot;'  Concatenate expressions #\rRulex consists of expressions. For example, a string is an expression. If we write several expressions in a row, they are matched one after the other:\n'hello' 'world' '!' # matches the string \u0026quot;helloworld!\u0026quot;  Alternatives #\rWhat if we want to match multiple strings? In a regex, we can enumerate multiple alternatives, divided by a |:\none|two|three|four|five  The same works in Rulex:\n'one' | 'two' | 'three' | 'four' | 'five'  This type of expression is called an alternation.\n"}),e.add({id:4,href:"/docs/language-tour/groups/",title:"Groups",description:"Learn about capturing and non-capturing and named groups",content:"Multiple expressions can be grouped together by wrapping them in (). This is useful when we have multiple alternatives that all start or end with the same thing:\n'tang' ('ible' | 'ent' | 'o')  This matches the words tangible, tangent and tango.\nCapturing groups #\rGroups can also be used to capture their content, for example to replace it with something else. In a regex, every group is a capturing group by default. This is not the case in rulex: Capturing groups must be prefixed with :.\n:('foo')  Capturing groups are consecutively numbered, to be able to refer to them later:\n:('Max' | 'Laura') (' is ' | ' was ') :('asleep' | 'awake')  The first group, containing the name, has index 1, the third group with the adverb has the index 2. The second group is skipped because it isn\u0026rsquo;t capturing (it isn\u0026rsquo;t prefixed with :).\nNamed capturing groups #\rBecause groups are non-capturing by default, you can add parentheses freely without accidentally changing the capturing group numbers. However, it\u0026rsquo;s usually better to use named capturing groups, so you don\u0026rsquo;t need to count groups and instead refer to each group by a name:\n:name('Max' | 'Laura') (' is ' | ' was ') :adverb('asleep' | 'awake')  Now, the first group is named name and the third group is named adverb.\n"}),e.add({id:5,href:"/docs/language-tour/repetitions/",title:"Repetitions",description:"How to repeat an expression, greedily or lazily",content:"When we want to match an expression multiple times, it would be cumbersome to repeat our expression. Instead, we can specify how often the expression should occur:\n('r' | 'w' | 'x' | '-'){9}  This matches an r, w, x or - character 9 times. For example, it would match the string rwxr-xr--, or xxrr-xr-w.\nWhat if we want to match strings of different lengths? Repetitions are quite flexible, so we can specify a lower and upper bound for the number of repetitions:\n('r' | 'w' | 'x' | '-'){3,9}  Greedy and lazy matching #\rThis matches at least 3 times and at most 9 times. The default repetition mode in rulex is greedy, like regexes. This means that rulex always tries to match an expression as many times as possible.\nIn situations where this is not desired, you can opt into non-greedy matching with the lazy keyword, for example:\n('r' | 'w' | 'x' | '-'){3,9} lazy '--'  When given the string rwxr--r--, rulex will first repeat the group 3 times (the minimum number of repetitions). Since there aren\u0026rsquo;t two dashes after 3 characters, it is forced to repeat a 4th time. rwxr is followed by two dashes, so rulex finds the match rwxr-- and returns. The other possible match, which is the entire string, isn\u0026rsquo;t found, because the repetition is \u0026ldquo;too lazy\u0026rdquo;.\nVariants of repetition #\rIf we want to match an expression arbitrarily often, without an upper bound, we can just omit it:\n'test'{3,}  There are three kinds of repetition that are very common: {0,} (zero or more), {1,} (one or more) and {0,1} (zero or one). These have dedicated symbols, *, + and ?:\n'test'* # match zero times or more 'test'+ # match one time or more 'test'? # match zero or one time  You can also add the lazy keyword to them to opt into lazy matching.\nEnable lazy matching globally #\rIf you enable the lazy mode, lazy repetition becomes the default, so it\u0026rsquo;s necessary to opt into greedy repetition with the greedy keyword:\nenable lazy; 'test'+ # this is lazy 'test'+ greedy  Lazy matching can be enabled or disabled in arbitrarily nested groups:\n(enable lazy; 'test'+ # this is lazy (disable lazy; 'test'+ # this is greedy ) 'test'+ # this is lazy )  "}),e.add({id:6,href:"/docs/language-tour/character-classes/",title:"Character Classes",description:"Matching a code point with certain properties",content:"What if we want to match an arbitrary word? Enumerating every single word is obviously not feasible, so what to do instead? We can simply enumerate the characters and repeat them:\n('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z')+  But this very verbose and still only matches lowercase letters. We programmers tend to be lazy, so there must be a more convenient solution!\nCharacter ranges #\rThis expression matches words that can contain uppercase and lowercase letters:\n['a'-'z' 'A'-'Z']+  What is this? The square brackets indicate that this is a character class. A character class always matches exactly 1 character (more precisely, a Unicode code point). This character class contains two ranges, one for lowercase letters and one for uppercase letters. Together, this matches any character that is either a lowercase or uppercase letter.\nIt\u0026rsquo;s also possible to add single characters, for example:\n['$' '_' 'a'-'z' 'A'-'Z']  When we have several characters in a character class that aren\u0026rsquo;t part of a range, we can simply put them into the same quotes:\n['$_' 'a'-'z' 'A'-'Z']  This is equivalent to ('$' | '_' | ['a'-'z' 'A'-'Z']), but it\u0026rsquo;s shorter and may be more efficient.\nCharacter ranges and Unicode #\rWhat is a range, exactly? Let\u0026rsquo;s see with an example:\n['0'-'z']  This doesn\u0026rsquo;t seem to make sense, but does work. If you compile it to a regex and try it out, you\u0026rsquo;ll notice that it matches numbers, lowercase and uppercase letters. However, it also matches a few other characters, e.g. the question mark ?.\nThe reason is that rulex uses Unicode, a standard that assigns every character a numeric value. When we write '0'-'z', rulex assumes that we want to match any character whose numeric value is somewhere between the value of '0' and the value of 'z'. This works well for letters (e.g. 'a'-'Z') and numbers ('0'-'9'), because these have consecutive numbers in Unicode. However, there are some special characters between digits, uppercase letters and lowercase letters:\n   Character Unicode value     '0' 48   '1' 49   '2' 50    \u0026hellip;   '9' 57   ':' 58   ';' 59   '\u0026lt;' 60   '=' 61   '\u0026gt;' 62   '?' 63   '@' 64   'A' 65   'B' 66    \u0026hellip;   'Z' 90   '[' 91   '\\' 92   ']' 93   '^' 94   '_' 95   '`' 96   'a' 97    \u0026hellip;   'z' 122    Why, you might ask? This is for historical reasons.\nUnicode properties #\rThe reason why Unicode was invented is that most people in the world don\u0026rsquo;t speak English, and many of them use languages with different alphabets. To support them, Unicode includes 144,697 characters covering 159 different scripts. Since we have a standard that makes it really easy to support different languages, there\u0026rsquo;s no excuse for not using it.\nThe character class ['a'-'z' 'A'-'Z'] only recognizes Latin characters. What should we do instead? We should use a Unicode category. In this case, Letter seems like an obvious candidate. Rulex makes it very easy to use Unicode categories:\n[Letter]  That\u0026rsquo;s it. This matches any letter from all 159 scripts! It\u0026rsquo;s also possible to match any character in a specific script:\n[Cyrillic Hebrew]  This matches a Cyrillic or Hebrew character. Not sure why you\u0026rsquo;d want to do that.\nSome regex engines can also match Unicode properties other than categories and scripts. Probably the most useful ones are\n Alphabetic (includes letters and marks that can appear in a word) White_Space Uppercase, Lowercase Emoji  You can see the full list of Unicode properties here.\nNegation #\rCharacter classes are negated by putting a ! in front of it. For example, !['a'-'f'] matches anything except a letter in the range from a to f.\nIt\u0026rsquo;s also possible to negate Unicode properties individually. For example, [Latin !Alphabetic] matches a code point that is either in the Latin script, or is not alphabetic.\nShorthand character classes #\rThere are a few shorthand character classes: word, digit, space, horiz_space and vert_space. They can be abbreviated with their first letter: w, d, s, h and v. Like Unicode properties, they must appear in square brackets.\n word matches a word character, i.e. a letter, digit or underscore. It\u0026rsquo;s equivalent to [Alphabetic Mark Decimal_Number Connector_Punctuation Join_Control]. digit matches a digit. It\u0026rsquo;s equivalent to Decimal_Number. space matches whitespace. It\u0026rsquo;s equivalent to White_Space. horiz_space matches horizontal whitespace (tabs and spaces). It\u0026rsquo;s equivalent to [U+09 Space_Separator]. vert_space matches vertical whitespace. It\u0026rsquo;s equivalent to [U+0A-U+0D U+85 U+2028 U+2029].  Note that word, digit and space only match ASCII characters, if the regex engine isn\u0026rsquo;t configured to be Unicode-aware. How to enable Unicode support is described here.\nThere are two more shorthands: [codepoint] (or [cp] for short), matches any Unicode code point; [.] matches any Unicode code point, except the ASCII line break \\n. These two shorthands are special, because they have to be the only thing in a character class; for example, [. 'x'] would be illegal, and also kind of useless.\nWhat if I don\u0026rsquo;t need Unicode support? #\rYou don\u0026rsquo;t have to use Unicode-aware character classes such as [word] if you know that the input is only ASCII. Unicode-aware matching can be considerably slower. For example, the [word] character class includes more than 100,000 code points, so matching a [ascii_word], which includes only 63 code points, is faster.\nRulex supports a number of ASCII-only shorthands:\n   Character class Equivalent     [ascii] [U+00-U+7F]   [ascii_alpha] ['a'-'z' 'A'-'Z']   [ascii_alnum] ['0'-'9' 'a'-'z' 'A'-'Z']   [ascii_blank] [' ' U+09],   [ascii_cntrl] [U+00-U+1F U+7F]   [ascii_digit] ['0'-'9']   [ascii_graph] ['!'-'~']   [ascii_lower] ['a'-'z']   [ascii_print] [' '-'~']   [ascii_punct] ['!'-'/' ':'-'@' '['-'`' '{'-'~']   [ascii_space] [' ' U+09-U+0D]   [ascii_upper] ['A'-'Z']   [ascii_word] ['0'-'9' 'a'-'z' 'A'-'Z' '_']   [ascii_xdigit] ['0'-'9' 'a'-'f' 'A'-'F']    Using them can improve performance, but be careful when you use them. If you aren\u0026rsquo;t sure if the input will ever contain non-ASCII characters, it\u0026rsquo;s better to err on the side of correctness, and use Unicode-aware character classes.\nNon-printable characters #\rCharacters that can\u0026rsquo;t be printed should be replaced with their hexadecimal Unicode code point. For example, you may write U+FEFF to match the Zero Width No-Break Space.\nThere are also 6 non-printable characters with a name:\n [n] is equivalent to [U+0A], the \\n line feed. [r] is equivalent to [U+0D], the \\r carriage return. [f] is equivalent to [U+0C], the \\f form feed. [a] is equivalent to [U+07], the \u0026ldquo;alert\u0026rdquo; or \u0026ldquo;bell\u0026rdquo; control character. [e] is equivalent to [U+0B], the \u0026ldquo;escape\u0026rdquo; control character.  Other characters have to be written in their hexadecimal form. Note that you don\u0026rsquo;t need to write leading zeroes, i.e. U+0 is just as ok as U+0000. However, it is conventional to write ASCII characters with two digits and non-ASCII characters with 4, 5 or 6 digits depending on their length.\nExamples #\rLet\u0026rsquo;s say we need to match a character that is either a letter, digit, underscore, dot or colon. We can use the word shorthand, which includes everything we need except the dot and colon:\n[word '.:']  What if we want to match a letter or digit, but not an underscore? We can list just the things we need:\n[Letter digit]  Another solution is to use negation to exclude the underscore from the word shorthand:\n![!word '_']  How does this work? Since the character class is negated, the part within the square bracket has to match anything except the things we want: Letters and digits. Since !word also doesn\u0026rsquo;t match underscores, we add '_' to get the desired result. This \u0026ldquo;double negation trick\u0026rdquo; can be used to remove some things from a shorthand.\n"}),e.add({id:7,href:"/docs/language-tour/boundaries/",title:"Boundaries",description:"Matching the start/end of a word or string",content:"Boundaries match a position in a string without consuming any code points. There are 4 boundaries:\n % matches a word boundary. It matches successfully if it is preceded, but not succeeded by a word character, or vice versa. For example, [cp] % [cp] matches A; and ;A, but not AA or ;;. !% matches a position that is not a word boundary. For example, [cp] !% [cp] matches aa and ::, but not a: or :a.  matches the start of the string. % matches the end of the string.  A word character is anything that matches [word]. If the regex engine is Unicode-aware, this is [Alphabetic Mark Decimal_Number Connector_Punctuation]. For some regex engines, Unicode-aware matching has to be enabled first (see here).\nIn JavaScript, % and !% is never Unicode-aware, even when the u flag is set. See here for more information.\n"}),e.add({id:8,href:"/docs/language-tour/lookaround/",title:"Lookaround",description:"Matching forwards or backwards without consuming characters",content:"Lookarounds provide the ability to see if the characters before or after the current position match a certain expression. There are four variants:\n  , a positive lookahead. For example, ( [w]) matches if the position is followed by a word character. That character isn\u0026rsquo;t included in the match.\n  , a positive lookbehind. For example, (matches if the position is directly after a word character.\n  !, a negative lookahead. For example (! [w]) matches if the position is not followed by a word character. Note that this also matches at the end of the string, so it\u0026rsquo;s not the same as ( ![w]), which would require that the position is followed by at least one character.\n  !, a negative lookbehind. For example (!matches if the position is not directly after a word character. This also matches at the start of the string, so it\u0026rsquo;s not the same as (.\n  Lookaround makes it possible to match a string in multiple ways. For example, (! ('_' | 'for' | 'while' | 'if') %) [w]+ % matches a string consisting of word characters, but not one of the keywords _, for, whileandif. Be careful when using this technique, because the lookahead might not match the same length as the expression after it. Here, we ensured that both match until the end of the word with %.\nSome regex engines don\u0026rsquo;t allow arbitrary expressions in a lookbehind. For example, they might forbid repetitions or expressions with an unknown length, such as 'hi' | 'world'. The reason for this is that they don\u0026rsquo;t support backwards matching; instead, when they see a lookbehind such as (, they see that it has a length of 3 code points, so they go back 3 characters in the string and match the expression 'foo' forwards. This requires that the length of the match is known. Rulex currently doesn\u0026rsquo;t validate this for regex engines with such a requirement.\n"}),e.add({id:9,href:"/docs/language-tour/ranges/",title:"Ranges",description:"Matching a number in a certain range",content:"Writing a regex matching a number in a certain range can be quite difficult. For example, the following regex matches a number between 0 and 255:\n(?:2(?:5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])  This has many downsides:\n It\u0026rsquo;s not readable It\u0026rsquo;s difficult to come up with It\u0026rsquo;s easy to make a mistake somewhere It\u0026rsquo;s inefficient; a typical regex engine needs to backtrack in several places  Rulex solves these problems with its range syntax:\nrange '0'-'255'  Rulex creates a DFA (deterministic finite automaton) from this, so the generated regex is optimal in terms of matching performance. Since the algorithm for creating this regex is extensively tested, you can also rely on it\u0026rsquo;s correctness. Here\u0026rsquo;s the regex generated from range '0'-'255':\n0|1[0-9]{0,2}|2(?:[0-4][0-9]?|5[0-5]?|[6-9])?|[3-9][0-9]?  Different bases #\rRulex can generate ranges in various bases. For example, to match hexadecimal numbers in a certain range, you might write:\nrange '10F'-'FFFF' base 16  This generates this regex:\n1(?:0(?:[0-9a-eA-E][0-9a-fA-F]|[fF][0-9a-fA-F]?)|[1-9a-fA-F][0-9a-fA-F]{1,2})|[2-9a-fA-F][0-9a-fA-F]{2,3}  Leading zeroes #\rIf you wish to support leading zeros, this is easy to achieve by putting '0'* in front:\n'0'* range '0'-'1024'  If the number should have a certain length, with leading zeroes added when necessary, rulex has a special syntax for this:\nrange '0000'-'1024'  This matches numbers in the specified range with exactly 4 digits, such as 0110 or 0026.\n"}),e.add({id:10,href:"/docs/language-tour/references/",title:"References",description:"Matching the same thing more than once",content:"Sometimes it\u0026rsquo;s useful to match the same text as we matched before. For example, to match strings in single or double quotes, we can write\n:(['\u0026quot;' \u0026quot;'\u0026quot;]) !['\u0026quot;' \u0026quot;'\u0026quot;]* ::1  This consists of three parts: First, there\u0026rsquo;s a capturing group matching a quote. We then match an arbitrary number of characters that aren\u0026rsquo;t quotes. Finally, there\u0026rsquo;s a ::1 reference. This matches the same text as was captured in capturing group number 1. In other words, if the string started with \", it also has to end with \", and if it started with ', it has to end with '.\nAnother application is XML tags:\n'\u0026lt;' :([word]+) '\u0026gt;' !['\u0026lt;']* '\u0026lt;/' ::1 '\u0026gt;'  This is by no means a complete XML parser, but it recognizes an XML tag (without attributes) that doesn\u0026rsquo;t contain other XML tags. For example, it correctly matches \u0026lt;span\u0026gt;Hello world\u0026lt;/span\u0026gt;. With a backreference, it ensures that the closing tag is the same as the opening tag.\nRulex has three kinds of references:\n Numeric references, e.g. ::3, match a capturing group by its number. Named references, e.g. ::name, match a named capturing group by its name. Relative references, e.g. ::-1 or ::+2, match a capturing group relative to the current position. For example, ::-1 matches the previous capturing group, ::+1 matches the next one.  Note that some regex engines only support backreferences, not forward references. And even when forward references are supported, the referenced group must have been already matched. I.e., this is not allowed:\n# doesn't work! ::1 :('test')  However, forward references can be used in repetitions to match what the referenced group captured in the previous repetition:\n(::forward | :forward('test') '!')*  This matches the text test!test, for example. In the first repetition, the second alternative matches test!, and the text test is captured by the forward capturing group. In the second iteration, the forward reference matches the text test.\n"}),e.add({id:11,href:"/docs/language-tour/variables/",title:"Variables",description:"Refactoring expressions so you Don't Repeat Yourself",content:"Variables are a powerful feature that is exclusive to rulex; because no regex engine offers this functionality, variables in rulex are \u0026ldquo;inlined\u0026rdquo;, i.e. substituted with their value recursively.\nThis means that variables don\u0026rsquo;t allow recursion, because otherwise the generated regular expression would have infinite size. But even without recursion, variables are a powerful and useful tool to create more complex expressions.\nVariables are declared with the let keyword:\nlet x = 'hello' | 'world';  The above will emit nothing, because the variable is declared, but not used. It could be used like this:\nlet x = 'hello' | 'world'; x '!'  This compiles to\n(?:hello|world)!  There can be multiple variable declarations. They can appear in any order, but the rulex expression using the variables must come last. For example, this is not allowed:\n# doesn't work! x '!' let x = 'hello' | 'world';  Declarations can depend on each other, as long as there is no cyclic dependency:\nlet c = 'test'; let a = b b; let b = c '!'; a  Declarations can be nested within a group; in that case, they can only be used within this group. However, variables can be used within a group even if they were declared outside:\nlet name = 'Max'; ( let greeting = 'Hello'; greeting ', ' name ) greeting # error!  In this example, greeting can\u0026rsquo;t be used in the last line because it is only accessible within the group where it was declared.\nNested declarations can have the same name as a declaration outside of the group:\nlet name = 'Max'; ( let name = 'Sophia'; 'Hello, ' name ) ' and ' name  This compiles to\nHello, Sophia and Max  "}),e.add({id:12,href:"/docs/language-tour/graphemes/",title:"Graphemes",description:"Matching what represents a single 'character'",content:"Some regex engines support matching a single Unicode grapheme cluster. A grapheme cluster is what comes closest to what we perceive as a character. It can consist of more than one code point. For example, emojis with modifiers (such as different skin tones, genders, etc.) usually consist of multiple code points.\nIn Rulex, matching a grapheme cluster is done with Grapheme. For example, to match a text with at most 400 characters, you can write\nGrapheme{0,400}  "}),e.add({id:13,href:"/docs/reference/grammar/",title:"Formal grammar",description:"Rulex' syntax specification",content:"Summary #\rThis document uses rulex syntax. Here\u0026rsquo;s an incomplete summary of the syntax, which should be enough to read the grammar:\n  Variables are declared as let var_name = expression;. This assigns expression to the variable var_name.\n  Verbatim text is wrapped in double quotes (\"\") or single quotes ('').\n  A * after a rule indicates that it repeats 0 or more times.\n  A + after a rule indicates that it repeats 1 or more times.\n  A ? after a rule indicates that the rule is optional.\n  Consecutive rules can be grouped together by wrapping them in parentheses (()).\n  Alternative rules are separated with a vertical bar (|).\n  Character classes are wrapped in square brackets ([]). A character class matches exactly one code point. It can contain\n sequences of characters (e.g. 'abdf', which matches either a, b, d or f) Unicode ranges (e.g. '0'-'9', which is equivalent to '0123456789') shorthands (e.g. w, which matches a letter, digit or the ASCII underscore _)  An exclamation mark (!) in front of the character class negates it. For example, ![w] matches anything except a letter, digit or ASCII underscore.\n  Whitespace #\rComments start with # and end at the end of the same line.\nComments and whitespace are ignored; they can be added anywhere, except in strings, in tokens (such as ), in words, numbers and code points (such as U+306F). For example,  can\u0026rsquo;t be written as  , but !'test'+ can be written as !  'test' +.\nWhitespace is required between consecutive words and code points, e.g. [a n Latin U+50].\nFormal grammar #\rExpression #\rlet Expression = Statement* OrExpression; let Statement = LetDeclaration | Modifier; let LetDeclaration = 'let' VariableName '=' OrExpression ';'; let Modifier = ('enable' | 'disable') BooleanSetting ';'; let BooleanSetting = 'lazy';  OrExpression #\rlet OrExpression = Alternative ('|' Alternative)*; let Alternative = FixExpression+;  FixExpression #\rAn expression which can have a prefix or suffix.\nlet FixExpression = LookaroundPrefix Expression | AtomExpression RepetitionSuffix;  Lookaround #\rlet LookaroundPrefix = '!'? ('\u0026lt;\u0026lt;' | '\u0026gt;\u0026gt;');  Repetitions #\rlet RepetitionSuffix = ('*' | '+' | '?' | RepetitionBraces) Quantifier?; let RepetitionBraces = '{' Number '}' | '{' Number ',' Number? '}'; let Number = '0' | '1'-'9' ('0'-'9')*; let Quantifier = 'greedy' | 'lazy';  AtomExpression #\rlet AtomExpression = Group | String | CharacterClass | Grapheme | Boundary | Reference | CodePoint | NumberRange | VariableName;  Group #\rlet Group = Capture? '(' Expression ')'; let Capture = ':' Name?; let Name = [w]+;  String #\rlet String = '\u0026quot;' !['\u0026quot;']* '\u0026quot;' | \u0026quot;'\u0026quot; ![\u0026quot;'\u0026quot;]* \u0026quot;'\u0026quot;;  CharacterClass #\rlet CharacterClass = '!'? '[' CharacterGroup ']'; let CharacterGroup = '.' | 'cp' | CharacterGroupMulti+; let CharacterGroupMulti = Range | Characters | CodePoint | NonPrintable | Shorthand | UnicodeProperty | PosixClass; let Range = Character '-' Character; let Characters = '\u0026quot;' !['\u0026quot;']* '\u0026quot;' | \u0026quot;'\u0026quot; ![\u0026quot;'\u0026quot;]* \u0026quot;'\u0026quot;; let Character = '\u0026quot;' !['\u0026quot;'] '\u0026quot;' | \u0026quot;'\u0026quot; ![\u0026quot;'\u0026quot;] \u0026quot;'\u0026quot; | CodePoint | NonPrintable; let NonPrintable = 'n' | 'r' | 't' | 'a' | 'e' | 'f'; let Shorthand = '!'? ('w' | 'word' | 'd' | 'digit' | 's' | 'space' | 'h' | 'horiz_space' | 'v' | 'vert_space' | 'l' | 'line_break'); let PosixClass = 'ascii_alpha' | 'ascii_alnum' | 'ascii' | 'ascii_blank' | 'ascii_cntrl' | 'ascii_digit' | 'ascii_graph' | 'ascii_lower' | 'ascii_print' | 'ascii_punct' | 'ascii_space' | 'ascii_upper' | 'ascii_word' | 'ascii_xdigit';  CodePoint #\rlet CodePoint = 'U+' ['0'-'9' 'a'-'f' 'A'-'F']{1,6} | 'U' ['0'-'9' 'a'-'f' 'A'-'F']{1,6};  Note that the second syntax exists mainly to be compatible with Rust tokenization.\nUnicodeProperty #\rDetails about supported Unicode properties can be found here.\nlet UnicodeProperty = '!'? [w]+;  Grapheme #\rlet Grapheme = 'Grapheme' | 'X';  Boundary #\rlet Boundary = '%' | '!' '%' | '\u0026lt;%' | '%\u0026gt;';  NumberRange #\rlet NumberRange = 'range' String '-' String Base?; let Base = 'base' Number;  VariableName #\rlet VariableName = [w]+;  Note about this grammar #\rEven though this grammar is written using rulex syntax, it isn\u0026rsquo;t actually accepted by the rulex compiler, because it uses cyclic variables.\n"}),e.add({id:14,href:"/docs/reference/unicode-properties/",title:"Unicode properties",description:"Exhaustive list of Unicode general categories, scripts, blocks and other properties supported by rulex",content:"Rulex supports the following kinds of Unicode properties:\n General categories Scripts Blocks Other boolean properties  However, not all regex engines support all of them. In particular, blocks and other properties are poorly supported.\nNote that regex requires underscores, and hyphens must be substituted with underscores.\nList of General Categories #\rEach line contains one category and its aliases. The words in each line can be used interchangeably.\n Cased_Letter, LC Close_Punctuation, Pe Connector_Punctuation, Pc Control, Cc, cntrl Currency_Symbol, Sc Dash_Punctuation, Pd Decimal_Number, Nd, digit, d Enclosing_Mark, Me Final_Punctuation, Pf Format, Cf Initial_Punctuation, Pi Letter, L Letter_Number, Nl Line_Separator, Zl Lowercase_Letter, Ll Mark, M, Combining_Mark Math_Symbol, Sm Modifier_Letter, Lm Modifier_Symbol, Sk Nonspacing_Mark, Mn Number, N Open_Punctuation, Ps Other, C Other_Letter, Lo Other_Number, No Other_Punctuation, Po Other_Symbol, So Paragraph_Separator, Zp Private_Use, Co Punctuation, P, punct Separator, Z, space, s Space_Separator, Zs Spacing_Mark, Mc Surrogate, Cs Symbol, S Titlecase_Letter, Lt Unassigned, Cn Uppercase_Letter, Lu  List of Scripts #\rEach line contains one script and its abbreviation, if it has one. The words in each line can be used interchangeably.\n Adlam, Adlm Ahom Anatolian_Hieroglyphs, Hluw Arabic, Arab Armenian, Armn Avestan, Avst Balinese, Bali Bamum, Bamu Bassa_Vah, Bass Batak, Batk Bengali, Beng Bhaiksuki, Bhks Bopomofo, Bopo Brahmi, Brah Braille, Brai Buginese, Bugi Buhid, Buhd Canadian_Aboriginal, Cans Carian, Cari Caucasian_Albanian, Aghb Chakma, Cakm Cham Chorasmian, Chrs Cherokee, Cher Common, Zyyy Coptic, Copt Cuneiform, Xsux Cypriot, Cprt Cypro_Minoan, Cpmn Cyrillic, Cyrl Deseret, Dsrt Devanagari, Deva Dives_Akuru, Diak Dogra, Dogr Duployan, Dupl Egyptian_Hieroglyphs, Egyp Elbasan, Elba Elymaic, Elym Ethiopic, Ethi Georgian, Geor Glagolitic, Glag Gothic, Goth Grantha, Gran Greek, Grek Gujarati, Gujr Gunjala_Gondi, Gong Gurmukhi, Guru Han, Hani Hangul, Hang Hanifi_Rohingya, Rohg Hanunoo, Hano Hatran, Hatr Hebrew, Hebr Hiragana, Hira Imperial_Aramaic, Armi Inherited, Zinh Inscriptional_Pahlavi, Phli Inscriptional_Parthian, Prti Javanese, Java Kaithi, Kthi Kannada, Knda Katakana, Kana Kayah_Li, Kali Kharoshthi, Khar Khitan_Small_Script, Kits Khmer, Khmr Khojki, Khoj Khudawadi, Sind Lao, Laoo Latin, Latn Lepcha, Lepc Limbu, Limb Linear_A, Lina Linear_B, Linb Lisu Lycian, Lyci Lydian, Lydi Mahajani, Mahj Makasar, Maka Malayalam, Mlym Mandaic, Mand Manichaean, Mani Marchen, Marc Medefaidrin, Medf Masaram_Gondi, Gonm Meetei_Mayek, Mtei Mende_Kikakui, Mend Meroitic_Cursive, Merc Meroitic_Hieroglyphs, Mero Miao, Plrd Modi Mongolian, Mong Mro, Mroo Multani, Mult Myanmar, Mymr Nabataean, Nbat Nandinagari, Nand New_Tai_Lue, Talu Newa Nko, Nkoo Nushu, Nshu Nyiakeng_Puachue_Hmong, Hmnp Ogham, Ogam Ol_Chiki, Olck Old_Hungarian, Hung Old_Italic, Ital Old_North_Arabian, Narb Old_Permic, Perm Old_Persian, Xpeo Old_Sogdian, Sogo Old_South_Arabian, Sarb Old_Turkic, Orkh Old_Uyghur, Ougr Oriya, Orya Osage, Osge Osmanya, Osma Pahawh_Hmong, Hmng Palmyrene, Palm Pau_Cin_Hau, Pauc Phags_Pa, Phag Phoenician, Phnx Psalter_Pahlavi, Phlp Rejang, Rjng Runic, Runr Samaritan, Samr Saurashtra, Saur Sharada, Shrd Shavian, Shaw Siddham, Sidd SignWriting, Sgnw Sinhala, Sinh Sogdian, Sogd Sora_Sompeng, Sora Soyombo, Soyo Sundanese, Sund Syloti_Nagri, Sylo Syriac, Syrc Tagalog, Tglg Tagbanwa, Tagb Tai_Le, Tale Tai_Tham, Lana Tai_Viet, Tavt Takri, Takr Tamil, Taml Tangsa, Tnsa Tangut, Tang Telugu, Telu Thaana, Thaa Thai Tibetan, Tibt Tifinagh, Tfng Tirhuta, Tirh Toto Ugaritic, Ugar Vai, Vaii Vithkuqi, Vith Wancho, Wcho Warang_Citi, Wara Yezidi, Yezi Yi, Yiii Zanabazar_Square, Zanb  List of Blocks #\r InBasic_Latin InLatin_1_Supplement InLatin_Extended_A InLatin_Extended_B InIPA_Extensions InSpacing_Modifier_Letters InCombining_Diacritical_Marks InGreek_and_Coptic InCyrillic InCyrillic_Supplementary InArmenian InHebrew InArabic InSyriac InThaana InDevanagari InBengali InGurmukhi InGujarati InOriya InTamil InTelugu InKannada InMalayalam InSinhala InThai InLao InTibetan InMyanmar InGeorgian InHangul_Jamo InEthiopic InCherokee InUnified_Canadian_Aboriginal_Syllabics InOgham InRunic InTagalog InHanunoo InBuhid InTagbanwa InKhmer InMongolian InLimbu InTai_Le InKhmer_Symbols InPhonetic_Extensions InLatin_Extended_Additional InGreek_Extended InGeneral_Punctuation InSuperscripts_and_Subscripts InCurrency_Symbols InCombining_Diacritical_Marks_for_Symbols InLetterlike_Symbols InNumber_Forms InArrows InMathematical_Operators InMiscellaneous_Technical InControl_Pictures InOptical_Character_Recognition InEnclosed_Alphanumerics InBox_Drawing InBlock_Elements InGeometric_Shapes InMiscellaneous_Symbols InDingbats InMiscellaneous_Mathematical_Symbols_A InSupplemental_Arrows_A InBraille_Patterns InSupplemental_Arrows_B InMiscellaneous_Mathematical_Symbols_B InSupplemental_Mathematical_Operators InMiscellaneous_Symbols_and_Arrows InCJK_Radicals_Supplement InKangxi_Radicals InIdeographic_Description_Characters InCJK_Symbols_and_Punctuation InHiragana InKatakana InBopomofo InHangul_Compatibility_Jamo InKanbun InBopomofo_Extended InKatakana_Phonetic_Extensions InEnclosed_CJK_Letters_and_Months InCJK_Compatibility InCJK_Unified_Ideographs_Extension_A InYijing_Hexagram_Symbols InCJK_Unified_Ideographs InYi_Syllables InYi_Radicals InHangul_Syllables InHigh_Surrogates InHigh_Private_Use_Surrogates InLow_Surrogates InPrivate_Use_Area InCJK_Compatibility_Ideographs InAlphabetic_Presentation_Forms InArabic_Presentation_Forms_A InVariation_Selectors InCombining_Half_Marks InCJK_Compatibility_Forms InSmall_Form_Variants InArabic_Presentation_Forms_B InHalfwidth_and_Fullwidth_Forms InSpecials  List of Other Supported Properties #\r White_Space Alphabetic, Alpha Noncharacter_Code_Point Default_Ignorable_Code_Point Logical_Order_Exception Deprecated Variation_Selector Uppercase, upper Lowercase, lower Soft_Dotted Case_Ignorable Changes_When_Lowercased Changes_When_Uppercased Changes_When_Titlecased Changes_When_Casefolded Changes_When_Casemapped Emoji Emoji_Presentation Emoji_Modifier Emoji_Modifier_Base Emoji_Component Extended_Pictographic Hex_Digit ASCII_Hex_Digit Join_Control Joining_Group Bidi_Control Bidi_Mirrored Bidi_Mirroring_Glyph ID_Continue ID_Start XID_Continue XID_Start Pattern_Syntax Pattern_White_Space Ideographic Unified_Ideograph Radical IDS_Binary_Operator IDS_Trinary_Operator Math Quotation_Mark Dash Sentence_Terminal Terminal_Punctuation Diacritic Extender Grapheme_Base Grapheme_Extend Regional_Indicator  "}),e.add({id:15,href:"/docs/examples/numbers/",title:"Example: Numbers",description:"Rational numbers in decimal notation with optional separating commas",content:"This regular expression matches rational numbers in decimal notation with optional separating commas:\n[-+]??\\b(?:0|[1-9](?:,??[0-9])*)(?:\\.[0-9]+)?\\b  Equivalent rulex:\n['-+']? % ('0' | ['1'-'9'] (','? ['0'-'9'])*) ('.' ['0'-'9']+)? %  "}),e.add({id:16,href:"/docs/examples/passwords/",title:"Example: Passwords",description:"Test if password satisfies strength requirements",content:"Here\u0026rsquo;s a regular expression that tests if a string contains at least one uppercase letter, lowercase letter, digit and punctuation/symbol code point, and is at least 8 code points long:\n^(?=[\\S\\s]*?\\d)(?=[\\S\\s]*?\\p{Ll})(?=[\\S\\s]*?\\p{Lu})(?=[\\S\\s]*?[\\pP\\pS])[\\S\\s]{8}  Equivalent rulex:\n\u0026lt;% (\u0026gt;\u0026gt; [cp]* [digit]) (\u0026gt;\u0026gt; [cp]* [Ll]) (\u0026gt;\u0026gt; [cp]* [Lu]) (\u0026gt;\u0026gt; [cp]* [P S]) [cp]{8}  "}),e.add({id:17,href:"/docs/examples/java-idents/",title:"Example: Java Identifiers",description:"Rulex matching a Java identifier",content:"Regex matching a Java identifier:\n[\\p{Connector_Punctuation}\\p{Currency_Symbol}\\p{Mark}\\p{Alphabetic}][\\p{Connector_Punctuation}\\p{Currency_Symbol}\\p{Mark}\\p{Alphabetic}\\p{Numeric}]*  With abbreviations:\n[\\p{Pc}\\p{Sc}\\p{M}\\p{Alpha}][\\p{Pc}\\p{Sc}\\p{M}\\p{Alpha}\\p{Numeric}]*  And as a rulex:\n[Pc Sc M Alpha] [Pc Sc M Alpha Numeric]*  "}),e.add({id:18,href:"/docs/examples/emails/",title:"Example: Email Addresses",description:"Match an RFC 5322 compliant email address",content:"This StackOverflow answer contains a massive regular expression for matching any RFC 5322 compliant email address:\n(?:[a-z0-9!#$%\u0026amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%\u0026amp;'*+/=?^_`{|}~-]+)*|\u0026quot;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\u0026quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])  If your regex engine supports insiginificant whitespace mode (?x), it can be written like this:\n(?x) (?: [a-z0-9!#$%\u0026amp;'*+/=?^_`{|}~-]+ (?: \\. [a-z0-9!#$%\u0026amp;'*+/=?^_`{|}~-]+ )* | \u0026quot; (?: [\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f] | \\\\ [\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f] )* \u0026quot; ) @ (?: (?: [a-z0-9] (?: [a-z0-9-]* [a-z0-9] )? \\. )+ [a-z0-9] (?: [a-z0-9-]* [a-z0-9] )? | \\[ (?: (?: (2 (5 [0-5] | [0-4] [0-9]) | 1 [0-9] [0-9] | [1-9]? [0-9]) ) \\. ){3} (?: (2 (5 [0-5] | [0-4] [0-9]) | 1 [0-9] [0-9] | [1-9]? [0-9]) | [a-z0-9-]* [a-z0-9] : (?: [\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f] | \\\\ [\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f] )+ ) \\] )  Here\u0026rsquo;s a straightforward translation into rulex:\n( ['a'-'z' '0'-'9' \u0026quot;!#$%\u0026amp;'*+/=?^_`{|}~-\u0026quot;]+ ('.' ['a'-'z' '0'-'9' \u0026quot;!#$%\u0026amp;'*+/=?^_`{|}~-\u0026quot;]+ )* | '\u0026quot;' ( [U+01-U+08 U+0b U+0c U+0e-U+1f U+21 U+23-U+5b U+5d-U+7f] | '\\' [U+01-U+09 U+0b U+0c U+0e-U+7f] )* '\u0026quot;' ) '@' ( ( ['a'-'z' '0'-'9'] ( ['a'-'z' '0'-'9' '-']* ['a'-'z' '0'-'9'] )? '.' )+ ['a'-'z' '0'-'9'] ( ['a'-'z' '0'-'9' '-']* ['a'-'z' '0'-'9'] )? | '[' (:(range '0'-'255') '.'){3} ( :(range '0'-'255') | ['a'-'z' '0'-'9' '-']* ['a'-'z' '0'-'9'] ':' ( [U+01-U+08 U+0b U+0c U+0e-U+1f U+21-U+5a U+53-U+7f] | '\\' [U+01-U+09 U+0b U+0c U+0e-U+7f] )+ ) ']' )  Notice how the complex logic for matching a number between \u0026lsquo;0\u0026rsquo; and \u0026lsquo;255\u0026rsquo; is replaced by a simple range expression in rulex.\nWe can also write the above as follows using variables:\nlet char_before_at = ['a'-'z' '0'-'9' \u0026quot;!#$%\u0026amp;'*+/=?^_`{|}~-\u0026quot;]; let quoted_char_before_at = [U+01-U+08 U+0b U+0c U+0e-U+1f U+21 U+23-U+5b U+5d-U+7f]; let escaped_char_before_at = '\\' [U+01-U+09 U+0b U+0c U+0e-U+7f]; let lower_digit = ['a'-'z' '0'-'9']; let lower_digit_dash = ['a'-'z' '0'-'9' '-']; let port_digit = [U+01-U+08 U+0b U+0c U+0e-U+1f U+21-U+5a U+53-U+7f]; let escaped_port_char = '\\' [U+01-U+09 U+0b U+0c U+0e-U+7f]; ( char_before_at+ ('.' char_before_at+)* | '\u0026quot;' (quoted_char_before_at | escaped_char_before_at)* '\u0026quot;' ) '@' ( (lower_digit (lower_digit_dash* lower_digit)? '.')+ lower_digit (lower_digit_dash* lower_digit)? | '[' (:(range '0'-'255') '.'){3} ( :(range '0'-'255') | lower_digit_dash* lower_digit ':' (port_digit | escaped_port_char)+ ) ']' )  "}),e.add({id:19,href:"/docs/examples/",title:"Examples",description:"Get inspiration from real-world examples",content:""}),e.add({id:20,href:"/docs/reference/",title:"Reference",description:"Detailed technical info",content:""}),e.add({id:21,href:"/docs/language-tour/",title:"Language Tour",description:"Learn how to use rulex.",content:""}),e.add({id:22,href:"/docs/get-started/",title:"Get Started",description:"Find out what rulex is.",content:""}),e.add({id:23,href:"/docs/",title:"Docs",description:"Rulex documentation.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()