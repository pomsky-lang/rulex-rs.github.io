<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Language Tour on</title><link>https://rulex-rs.github.io/docs/language-tour/</link><description>Recent content in Language Tour on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 17 May 2022 13:55:00 +0000</lastBuildDate><atom:link href="https://rulex-rs.github.io/docs/language-tour/index.xml" rel="self" type="application/rss+xml"/><item><title>Basics</title><link>https://rulex-rs.github.io/docs/language-tour/basics/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/basics/</guid><description>First, let&amp;rsquo;s get familiar with the basic building blocks of the language.
Rulex expressions (rulexes for short) describe the syntactical structure of a text. There are several kinds of expressions, which will be explained now.
In Rulex, whitespace is insignificant, except between quotes. This means that we can add spaces and line breaks to make the code look clearer. We can also add comments to explain what the expressions are doing.</description></item><item><title>Groups</title><link>https://rulex-rs.github.io/docs/language-tour/groups/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/groups/</guid><description>Multiple expressions can be grouped together by wrapping them in (). This is useful when we have multiple alternatives that all start or end with the same thing:
'tang' ('ible' | 'ent' | 'o') This matches the words tangible, tangent and tango.
Capturing groups #
Groups can also be used to capture their content, for example to replace it with something else. In a regex, every group is a capturing group by default.</description></item><item><title>Repetitions</title><link>https://rulex-rs.github.io/docs/language-tour/repetitions/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/repetitions/</guid><description>When we want to match an expression multiple times, it would be cumbersome to repeat our expression. Instead, we can specify how often the expression should occur:
('r' | 'w' | 'x' | '-'){9} This matches an r, w, x or - character 9 times. For example, it would match the string rwxr-xr--, or xxrr-xr-w.
What if we want to match strings of different lengths? Repetitions are quite flexible, so we can specify a lower and upper bound for the number of repetitions:</description></item><item><title>Character Classes</title><link>https://rulex-rs.github.io/docs/language-tour/character-classes/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/character-classes/</guid><description>What if we want to match an arbitrary word? Enumerating every single word is obviously not feasible, so what to do instead? We can simply enumerate the characters and repeat them:
('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z')+ But this very verbose and still only matches lowercase letters.</description></item><item><title>Boundaries</title><link>https://rulex-rs.github.io/docs/language-tour/boundaries/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/boundaries/</guid><description>Boundaries match a position in a string without consuming any code points. There are 4 boundaries:
% matches a word boundary. It matches successfully if it is preceded, but not succeeded by a word character, or vice versa. For example, [cp] % [cp] matches A; and ;A, but not AA or ;;. !% matches a position that is not a word boundary. For example, [cp] !% [cp] matches aa and ::, but not a: or :a.</description></item><item><title>Lookaround</title><link>https://rulex-rs.github.io/docs/language-tour/lookaround/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/lookaround/</guid><description>Lookarounds provide the ability to see if the characters before or after the current position match a certain expression. There are four variants:
, a positive lookahead. For example, ( [w]) matches if the position is followed by a word character. That character isn&amp;rsquo;t included in the match.
, a positive lookbehind. For example, (matches if the position is directly after a word character.
!</description></item><item><title>Ranges</title><link>https://rulex-rs.github.io/docs/language-tour/ranges/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/ranges/</guid><description>Writing a regex matching a number in a certain range can be quite difficult. For example, the following regex matches a number between 0 and 255:
(?:2(?:5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]) This has many downsides:
It&amp;rsquo;s not readable It&amp;rsquo;s difficult to come up with It&amp;rsquo;s easy to make a mistake somewhere It&amp;rsquo;s inefficient; a typical regex engine needs to backtrack in several places Rulex solves these problems with its range syntax:</description></item><item><title>References</title><link>https://rulex-rs.github.io/docs/language-tour/references/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/references/</guid><description>Sometimes it&amp;rsquo;s useful to match the same text as we matched before. For example, to match strings in single or double quotes, we can write
:(['&amp;quot;' &amp;quot;'&amp;quot;]) !['&amp;quot;' &amp;quot;'&amp;quot;]* ::1 This consists of three parts: First, there&amp;rsquo;s a capturing group matching a quote. We then match an arbitrary number of characters that aren&amp;rsquo;t quotes. Finally, there&amp;rsquo;s a ::1 reference. This matches the same text as was captured in capturing group number 1.</description></item><item><title>Variables</title><link>https://rulex-rs.github.io/docs/language-tour/variables/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/variables/</guid><description>Variables are a powerful feature that is exclusive to rulex; because no regex engine offers this functionality, variables in rulex are &amp;ldquo;inlined&amp;rdquo;, i.e. substituted with their value recursively.
This means that variables don&amp;rsquo;t allow recursion, because otherwise the generated regular expression would have infinite size. But even without recursion, variables are a powerful and useful tool to create more complex expressions.
Variables are declared with the let keyword:
let x = 'hello' | 'world'; The above will emit nothing, because the variable is declared, but not used.</description></item><item><title>Graphemes</title><link>https://rulex-rs.github.io/docs/language-tour/graphemes/</link><pubDate>Tue, 17 May 2022 13:55:00 +0000</pubDate><guid>https://rulex-rs.github.io/docs/language-tour/graphemes/</guid><description>Some regex engines support matching a single Unicode grapheme cluster. A grapheme cluster is what comes closest to what we perceive as a character. It can consist of more than one code point. For example, emojis with modifiers (such as different skin tones, genders, etc.) usually consist of multiple code points.
In Rulex, matching a grapheme cluster is done with Grapheme. For example, to match a text with at most 400 characters, you can write</description></item></channel></rss>